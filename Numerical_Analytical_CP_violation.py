# -*- coding: utf-8 -*-
"""Hypergeometric_diffEqn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rdf4vH1qCSOt__mA5a8IXdTS0kgTYoxu
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from scipy.integrate import ode
from scipy.integrate import complex_ode
from scipy.integrate import solve_ivp
from scipy.integrate import odeint
from mpmath import *
mp.dps = 25; mp.pretty = True

"""## Declaration of variables and Macros"""

no_of_mode_functions = 2 ## This indicates the no. of mode functions present in the coupled
                         ## first order differential equations. In this example we have u_{h+,11}
                         ## and u_{h-,11}

GAMMA_FACTOR  = .01      ## gamma is the inverse time scale over which the bubble wall moves. gamma
                         ## expressed in terms of p_{R,11}. Thus gamma = GAMMA_FACTOR * p_{R_11}.

degree = 100 ## The degree to which the taylor expansion of (1-time)^(-1) must be calculated.

iota = complex(0,1)      ## complex j

z_time_sweep = 100       ## total number of z samples
z_time_min = 0.01           ## start value for z
z_time_max = 0.99           ## end value for z.    |z| < 1. Note: we consider only real values for z.

time_steps = 1/z_time_sweep

q_real_sweep = 1       ## total number of samples for the parameter q_real_ij
q_real_min = 5      ## q_real_ij start
q_real_max = 5     ## q_real_ij end 

q_imag_sweep = 1       ## total number of samples for the parameter q_imag_ij
q_imag_min = 5      ## q_imag_ij start
q_imag_max = 5       ## q_imag_ij end 

p_real_sweep = 1       ## total number of samples for the parameter p_real_ij
p_real_min = 5     ## p_real_ij start
p_real_max = 5        ## p_real_ij end 

k_sweep = 1       ## total number of samples for the parameter momentum k
k_min = 1        ## k start value
k_max = 1        ## k end value

heli = +1          ## helicity value (+1 or -1). default value set to +1

##### INDEXING MACROS ###########
PARAM = 6 # No. of parameters

HELI = 0
K = 1
Q_R_11 = 2
Q_I_11 = 3
P_R_11 = 4
GAM = 5

param_text = ['helicity:','|k|:','q_real_11:','q_imag_11:','p_real_11:','gamma:']
 
lines = np.zeros([PARAM],dtype = np.str_)


U_P_11_R = 0
U_P_11_I = 1
U_M_11_R = 2
U_M_11_I = 3


## Initial values for u_h_plus_11 and u_h_minus_11
## Will not normalize this as of now.
## Initial values same as that used to plot the analytical solution.
## 
init_u_h_11 = (0.65,0.65,0.01,0.01)

z = np.linspace(0,z_time_max,z_time_sweep)

########## parameter space ###########
param_sweep = 1 # no. of samples per parameter. default set to 1. 

param_space = np.zeros([PARAM,param_sweep]) ## param_space[0] = helicty
                                            ## param_space[1] = momentum k
                                            ## param_space[2] = q_r_11
                                            ## param_space[3] = q_i_11
                                            ## param_space[4] = p_r_11
                                            ## param_space[5] = gamma  

## Array to hold the final value of the solution to the differential equation

u_soln = np.zeros([PARAM,z_time_sweep],dtype = np.complex_)
numerical_solver = np.zeros([z_time_sweep,2*no_of_mode_functions])
numerical_solver.T[2]
t = np.linspace(z_time_min,z_time_max,z_time_sweep)


######################## PARAMETERS FOR CALCULATION OF ANALYTICAL SOLUTION ##########################

p_m_label = '+'     ## This sets the label in the plots
p_m = +1            ## p_m stands for the plus/minus for u_h_11_plus/u_h_11_minus 





z_time_min_a = .01              ## Time step parameters for the analytical solution.
z_time_max_a = 0.99             ## subscript _a indicates analytical
z_time_sweep_a = z_time_sweep
z_time = np.linspace(z_time_min_a,z_time_max_a,z_time_sweep_a)
u_h_11_data = np.zeros(z_time_sweep_a)
print(lines)

"""**Function** : u_diff(time,u_h_11,arg1)



**Description** : this function describes the differential equation for u_h_plus_11 and u_h_minus_11. arg1 (PARAM,param_sweep) type array takes in the parameters as follows in the order:
* helicty
* momentum k
* q_r_11
* q_i_11
* p_r_11
* gamma


"""

def u_diff(time,u_pm_11):
  factor = 0
  for n in range(degree):
    factor += ((time)**n)/(2*param_space[GAM,0]*time) ## for time<1 we have (1-time)^(-1) ~ 1 + time + time^2 + time^3 + ..... + time^n 
  
  return [factor*( -param_space[HELI,0]*param_space[K,0]*u_pm_11[U_M_11_I] - param_space[Q_I_11,0]*u_pm_11[U_M_11_R] + param_space[P_R_11,0]*(1 - 2*time)*u_pm_11[U_P_11_I] + param_space[Q_R_11,0]*u_pm_11[U_P_11_I] ),
        factor*( param_space[HELI,0]*param_space[K,0]*u_pm_11[U_M_11_R] - param_space[Q_I_11,0]*u_pm_11[U_M_11_I] - param_space[P_R_11,0]*(1 - 2*time)*u_pm_11[U_P_11_R] -  param_space[Q_R_11,0]*u_pm_11[U_P_11_R]),
        factor*( -param_space[HELI,0]*param_space[K,0]*u_pm_11[U_P_11_I] + param_space[Q_I_11,0]*u_pm_11[U_P_11_R] - param_space[P_R_11,0]*(1 - 2*time)*u_pm_11[U_M_11_I] - param_space[Q_R_11,0]*u_pm_11[U_M_11_I]),
         factor*( param_space[HELI,0]*param_space[K,0]*u_pm_11[U_P_11_R] + param_space[Q_I_11,0]*u_pm_11[U_P_11_I] + param_space[P_R_11,0]*(1 - 2*time)*u_pm_11[U_M_11_R] + param_space[Q_R_11,0]*u_pm_11[U_M_11_R])]

"""**FUNCTION**: u_diff_jacob(time,u_pm_11,arg1)

**DESCRIPTION**: Returns the jacobian of the right hand side of the differential equation. This is 2*2 matrix for a coupled differential equation with two variables u_h_plus_11 and u_h_minus_11. The function takes in the same arguments as for the function u_diff(time,u_pm_11,arg1).

**FUNCTION**: initi_values()

**DESCRIPTION**: Initializes all parameters
"""

def init_values():
  param_space[HELI,0] = +1
  param_space[K,0] = np.linspace(k_min,k_max,k_sweep)
  param_space[Q_R_11,0] = np.linspace(q_real_min,q_real_max,q_imag_sweep)
  param_space[Q_I_11,0] = np.linspace(q_imag_min,q_imag_max,q_imag_sweep)
  param_space[P_R_11,0] = np.linspace(p_real_min,p_real_max,p_real_sweep)
  param_space[GAM,0] = GAMMA_FACTOR * param_space[P_R_11,0]
  global lines 
  lines = [str(x) for x in param_space[:,0]]
  print("init:",lines)

def numer_analysis():
  t = np.linspace(z_time_min,z_time_max,z_time_sweep)
  return solve_ivp(u_diff,[z_time_min,z_time_max],y0=init_u_h_11,t_eval= t, method = 'RK45',dense_output=True)

############# FUNCTIONS THAT PLOT THE ANALYTICAL SOLUTION ############################
def omega_h(plus_minus, k, p_r_11, q_r_11, q_i_11):
  sum = k**2 + q_i_11**2 + (p_r_11 - plus_minus*q_r_11)**2
  return np.sqrt(sum)

def alpha(gamma,k, p_r_11, q_r_11, q_i_11):
  return -(iota*omega_h(-1,k, p_r_11, q_r_11, q_i_11)/(2*gamma))

def beta(gamma,k, p_r_11, q_r_11, q_i_11):
  return -(iota*omega_h(+1,k, p_r_11, q_r_11, q_i_11)/(2*gamma))  

def param_a(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11):
  return (alpha(gamma, k, p_r_11, q_r_11, q_i_11) + beta(gamma, k, p_r_11, q_r_11, q_i_11) + 1 - plus_minus*(iota*p_r_11/gamma))

def param_b(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11):
  return (alpha(gamma, k, p_r_11, q_r_11, q_i_11) + beta(gamma, k, p_r_11, q_r_11, q_i_11) + plus_minus*(iota*p_r_11/gamma))

def param_c(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11):
  return (2*alpha(gamma, k, p_r_11, q_r_11, q_i_11) + 1)


def u_h_11(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11,z):
  
  hypergeometric_param_a = param_a(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11)
  hypergeometric_param_b = param_b(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11)
  hypergeometric_param_c = param_c(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11)

  if plus_minus == +1:
    coeff_1 = np.sqrt(   (omega_h(-plus_minus, k, p_r_11, q_r_11, q_i_11) + plus_minus*(p_r_11 + q_r_11))/ (2*omega_h(-plus_minus, k, p_r_11, q_r_11, q_i_11))   )
    coeff_2 = (z**(alpha(gamma,k, p_r_11, q_r_11, q_i_11)))*(1-z)**(beta(gamma,k, p_r_11, q_r_11, q_i_11))
    return coeff_1 * coeff_2 * hyp2f1(hypergeometric_param_a,hypergeometric_param_b,hypergeometric_param_c,z)
  
  if plus_minus == -1:
    coeff_1 = np.sqrt(   (omega_h(plus_minus, k, p_r_11, q_r_11, q_i_11) + plus_minus*(p_r_11 + q_r_11))/ (2*omega_h(plus_minus, k, p_r_11, q_r_11, q_i_11))   )
    coeff_2 = z**(alpha(gamma,k, p_r_11, q_r_11, q_i_11))*(1-z)**(beta(gamma,k, p_r_11, q_r_11, q_i_11))
    coeff_3 = -(heli*k - iota*q_i_11)/(np.sqrt(k**2 + q_i_11**2))
    return coeff_3 * coeff_1 * coeff_2 * hyp2f1(hypergeometric_param_a,hypergeometric_param_b,hypergeometric_param_c,z)



### Instead of plotting u_h_11, here we will plot the 
### the absolute value squared i.e. |u_h_11|^(2)
def plot_u_h_11(gamma,plus_minus, k, p_r_11, q_r_11, q_i_11):
  print("gamma:",gamma)
  print("k:",k)
  for time in range(z_time_sweep_a):
    u_h_11_data[time] =  np.absolute(u_h_11(gamma,plus_minus,k,p_r_11,q_r_11,q_i_11,z_time[time]))**2
  
  u_h_11_plotter(u_h_11_data,plus_minus)

### Function to plot mode function absolute squared
 
def u_h_11_plotter(data,plus_minus):
  if plus_minus == +1:
    p_m_label = '+'
  if plus_minus == -1:
    p_m_label = '-' 
  z_time_2 = np.linspace(0,z_time_max_a,z_time_sweep_a)
  plt.plot(z_time_2,data,label='analytical')
  plt.xlabel('z')
  plt.ylabel(r'$| u_{h%s,11} |^{2}$'%p_m_label)
  plt.legend()
  plt.savefig('|u_h%s,11|^2.pdf'%p_m_label)

def print_parameters(parameters):
  with open('Parameters.txt', 'w') as f:
    i=0
    for line in parameters:
        f.write(param_text[i])
        f.write(line)
        i = i + 1
        f.write('\n\n\n\t\t')

init_values() # intializes the parameter space with the values
print_parameters(lines) ## Prints the values for the parameter space in Parameters.txt file




print('##################################################')
numerical_solver = numer_analysis() ## Solves the differential equation using Runge-Kutta method and returns the data corresponding to each time step
abs_plus_11 = (numerical_solver.y[0]**2 + numerical_solver.y[1]**2 )/(numerical_solver.y[0]**2 + numerical_solver.y[1]**2 + numerical_solver.y[2]**2 + numerical_solver.y[3]**2) ## calculates normalized | u_h_plus_11 |^2
abs_minus_11 = numerical_solver.y[2]**2 + numerical_solver.y[3]**2 /(numerical_solver.y[0]**2 + numerical_solver.y[1]**2 + numerical_solver.y[2]**2 + numerical_solver.y[3]**2)  ## calculates normalized | u_h_minus_11 |^2

plt.plot(z,abs_plus_11,label='numerical') ## plots numerical solution | u_h_plus_11 |^2 against the time step z
p_m = +1
plot_u_h_11(param_space[GAM,0],p_m,param_space[K,0],param_space[P_R_11,0],param_space[Q_R_11,0],param_space[Q_I_11,0]) ## plots the analytical solution for | u_h_plus_11 |^2 (p_m set to +1) against time step z 
                                                                                                                       ## saves the plot to file u_h+,11.pdf           
plt.show()  

plt.plot(z,abs_minus_11,label='numerical')   ## plots numerical solution | u_h_minus_11 |^2 against the time step z
p_m = -1
plot_u_h_11(param_space[GAM,0],p_m,param_space[K,0],param_space[P_R_11,0],param_space[Q_R_11,0],param_space[Q_I_11,0]) ## plots the analytical solution for | u_h_minus_11 |^2 (p_m set to -1) against time step z
                                                                                                                       ## ## saves the plot to file u_h-,11.pdf               
plt.show()